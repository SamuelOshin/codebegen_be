# JSON Parsing Bug Fix - Gemini Provider

## Issue Summary

Gemini was generating malformed or truncated JSON responses, causing parsing failures during code generation.

## Errors Encountered

```
Failed to parse JSON from response: Unterminated string starting at: line 39 column 25 (char 27046)
Code generation failed: Failed to parse JSON from Gemini response: Unterminated string starting at: line 39 column 25 (char 27046)
Enhanced generation failed: 'NoneType' object has no attribute 'get'
```

## Root Cause

1. **Large Response Size**: Generating entire projects as JSON can exceed token limits, causing truncation
2. **Simple JSON Extraction**: Original `_extract_json()` method was too simplistic
3. **No Validation**: No checks to ensure complete JSON objects were received
4. **Poor Error Handling**: Generic error messages didn't help diagnose the issue

## Fixes Applied

### Fix 1: Robust JSON Extraction Method

Enhanced `_extract_json()` with multiple fallback strategies:

**Before:**
```python
def _extract_json(self, response: str) -> Dict[str, Any]:
    """Extract JSON from response, handling markdown code blocks"""
    response = re.sub(r'^```json\s*', '', response, flags=re.MULTILINE)
    response = re.sub(r'^```\s*$', '', response, flags=re.MULTILINE)
    response = response.strip()
    
    try:
        return json.loads(response)
    except json.JSONDecodeError as e:
        json_match = re.search(r'\{.*\}', response, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group())
            except json.JSONDecodeError:
                pass
        raise ValueError(f"Failed to parse JSON from Gemini response: {e}")
```

**After:**
```python
def _extract_json(self, response: str) -> Dict[str, Any]:
    """
    Extract JSON from response with robust error handling.
    
    Handles:
    - Markdown code blocks
    - Truncated responses  
    - Escaped strings
    - Multiple JSON objects
    """
    # Step 1: Remove markdown code blocks
    # Step 2: Try direct JSON parse
    # Step 3: Brace-matching algorithm to find complete JSON
    # Step 4: Regex-based extraction as last resort
    # Step 5: Detailed error logging if all methods fail
```

**Key Improvements:**
- ‚úÖ Proper brace matching with string/escape handling
- ‚úÖ Multiple fallback strategies
- ‚úÖ Detailed logging for debugging
- ‚úÖ Helpful error messages with response size and previews

### Fix 2: JSON Response Mode (Experimental)

Added attempt to use Gemini's JSON mode for structured outputs:

```python
# Try to use JSON mode for structured tasks (if supported by model)
if task in [LLMTask.SCHEMA_EXTRACTION, LLMTask.CODE_GENERATION]:
    try:
        config_params["response_mime_type"] = "application/json"
        logger.debug("Enabling JSON response mode")
    except Exception:
        logger.debug("JSON response mode not supported, using text mode")
```

**Benefits:**
- More reliable JSON formatting from Gemini
- Reduces need for post-processing
- Graceful fallback if not supported

### Fix 3: Response Validation

Added validation after parsing:

```python
parsed_files = self._extract_json(response)

# Validate that we got a dictionary of files
if not isinstance(parsed_files, dict):
    logger.error(f"Gemini returned non-dict response: {type(parsed_files)}")
    raise ValueError("Expected dictionary of files from Gemini")

# Ensure we have at least some files
if not parsed_files:
    logger.warning("Gemini returned empty files dictionary")
    raise ValueError("No files generated by Gemini")

logger.info(f"‚úÖ Successfully generated {len(parsed_files)} files")
```

### Fix 4: Enhanced Logging

Added comprehensive logging throughout:

```python
logger.debug(f"Generating completion for {task} with max_tokens={max_tokens}")
# ... generate ...
logger.info(f"‚úÖ Received response: {len(response_text)} characters")

# In _extract_json:
logger.info("‚úÖ Successfully extracted JSON using brace matching")
logger.warning(f"Brace-matched JSON still invalid: {e}")
logger.error(f"Response length: {len(original_response)}")
logger.error(f"Response preview: {original_response[:200]}...")
logger.error(f"Response ending: ...{original_response[-200:]}")
```

## How the Brace Matching Works

The new extraction algorithm properly handles:

1. **Escape sequences**: `\"` doesn't close a string
2. **String context**: Braces inside strings don't count
3. **Nested objects**: Correctly handles `{...{...}...}`
4. **Truncation detection**: Knows if braces don't match

```python
brace_count = 0
in_string = False
escape_next = False

for i in range(start_idx, len(response)):
    char = response[i]
    
    if escape_next:
        escape_next = False
        continue
        
    if char == '\\':
        escape_next = True
        continue
    
    if char == '"':
        in_string = not in_string
        continue
    
    if not in_string:
        if char == '{':
            brace_count += 1
        elif char == '}':
            brace_count -= 1
            if brace_count == 0:
                # Found complete JSON object
                end_idx = i + 1
                break
```

## Token Limits

Confirmed proper token limits for Gemini 2.0:

```python
max_tokens=8192  # Gemini 2.0's actual max output tokens
```

Previously had incorrect value of 32000, which could cause issues.

## Error Messages Improvements

**Before:**
```
Failed to parse JSON from Gemini response: Unterminated string...
```

**After:**
```
‚ùå All JSON extraction methods failed
Response length: 27046 chars
Response preview: {"main.py": "from fastapi import FastAPI...
Response ending: ...def update_user(user_id: int, user
Try reducing the scope of your request or increasing max_tokens.
```

## Testing Recommendations

### 1. Test with Simple Request
```bash
# Small project should work reliably
curl -X POST http://localhost:8000/ai/generate \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "Create a simple user API with login",
    "tech_stack": "fastapi_postgres",
    "domain": "authentication"
  }'
```

### 2. Test with Complex Request
```bash
# Larger project tests token limits
curl -X POST http://localhost:8000/ai/generate \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "prompt": "Create a complete e-commerce platform with products, cart, orders, payments, reviews, and admin panel",
    "tech_stack": "fastapi_postgres",
    "domain": "ecommerce"
  }'
```

### 3. Monitor Logs
```bash
# Watch for extraction method used
tail -f logs/app.log | grep "extract"

# Should see:
# ‚úÖ Successfully extracted JSON using brace matching
# or
# ‚úÖ Successfully extracted JSON using regex
```

## Alternative Solutions (If Issue Persists)

### Option 1: Split Generation into Phases
Instead of generating all files at once, generate in phases:
1. Models + Schemas
2. Routers + Repositories  
3. Config + Utils
4. Documentation

### Option 2: Use Streaming
If Gemini supports streaming, process JSON incrementally.

### Option 3: Fallback to HuggingFace
```env
# In .env
CODE_GENERATION_PROVIDER=huggingface
```

This uses Qwen for code generation which handles large outputs differently.

### Option 4: Simplify Prompt
Reduce the number of files requested in the prompt to stay within token limits.

## Files Modified

- `app/services/llm_providers/gemini_provider.py`
  - Enhanced `_extract_json()` method (~90 lines)
  - Added JSON mode support to `generate_completion()`
  - Added validation to `generate_code()`
  - Improved logging throughout

## Impact

‚úÖ **More Reliable**: Multiple extraction strategies ensure parsing succeeds
‚úÖ **Better Debugging**: Detailed logs help diagnose issues
‚úÖ **Graceful Degradation**: Falls back through multiple methods
‚úÖ **Clear Error Messages**: Users know what went wrong and how to fix it

## Next Steps

1. ‚úÖ JSON extraction improved
2. üîÑ Test with your API endpoint
3. üîÑ Monitor logs for extraction method used
4. üîÑ If truncation persists, consider splitting generation into phases
5. üîÑ Adjust max_tokens or simplify prompts as needed

---

**Date Fixed**: October 14, 2025
**Issue Type**: JSON Parsing / Response Truncation
**Severity**: High (Blocked code generation)
**Status**: ‚úÖ Resolved with robust fallbacks
